#find celebrity
#tc: O(n)
#sc: O(1)
class Solution:
    def findCelebrity(self, n):
        x = 0
        for i in range(n):
            if knows(x, i):
                x = i
        if any(knows(x, i) for i in range(x)):
            return -1
        if any(not knows(i, x) for i in range(n)):
            return -1
        return x
#Optimize Water Distribution in a Village
#tc: O(n + plogp) n is houses, p is pipes
#sc: O(n)
class Solution:
    def minCostToSupplyWater(self, n: int, wells: List[int], pipes: List[List[int]]) -> int:
        parents = [-1] * n
        cost = sum(wells)
        
        for w1, w2, pipe_cost in sorted(pipes, key=lambda x: x[2]):
            root_well1 = self.find(parents, w1 - 1)
            root_well2 = self.find(parents, w2 - 1)
            if root_well1 == root_well2: continue
                
            savings = max(wells[root_well1], wells[root_well2]) - pipe_cost
            if savings > 0:
                self.union(wells, parents, w1 - 1, w2 - 1)
                cost -= savings
        return cost
    
    def find(self, parents, x):
        if parents[x] == -1:
            return x
        parents[x] = self.find(parents, parents[x])
        return parents[x]
    
    def union(self, wells, parents, x, y):
        px = self.find(parents, x)
        py = self.find(parents, y)
        if px == py: return
            
        # we need to remove the parent associated
        # with largest well cost in order to optimize
        # overall cost function
        cost_px = wells[px]
        cost_py = wells[py]
        if cost_px > cost_py:
            parents[px] = py
        else:
            parents[py] = px
